---
layout: post
title:  "알고리즘 - DFA"
categories: algorithm
use_math: true
---

### Deterministic Finite Automata (결정적 유한 오토마타)

이전에 알고리즘을 공부하다가 우연히 오토마타를 알게 되었다. 문자열에서 특정한 문자가 들어가있는지 알아보는것이 정규표현식이랑 비슷하여 공부를 해보았다.

생각해보면 정규표현식과 동일하므로, 정규표현식 문제들은 모두 DFA로 치환하여 구할 수 있다.


#### 오토마타

다음은 오토마타의 성질이다.
- 유한개의 내부상태
- 유한 / 무한개의 크기를 담는 저장공간
- 입력이 주어지면 정해진 방식에 따라 상태 전이

자세한 오토마타의 내용은 justice hui 님의 강의 자료와 알고리즘 트레이닝 을 참고하면 될것같다.

해당 DFA를 사용하기 위해 DP를 사용할 수 있으며
DP(x,y) : 상태 번호가 x일때, y가 주어질때 이동하는 상태번호 라고 정할수 있다.

이를 이용하여 BOJ 1013을 풀수 있었다.

### BOJ 1013

- 주어진 식 (100+1+|01)+ 을 이용하여 주어진 문자열이 해당 식을 만족하는지 여부 판단
- 1과 0이 주어지고, 해당 숫자에 따라 상태가 바뀐다

q0은 종료 상태이다. 어떤 상태든 q0으로 가는 상태 즉 0으로 가는 상태는 모두 out 조건이다.

모든 문자열은 q1에서 시작한다.
q1 -> 1 -> q2 q1에서 q2로 이동하기 위해서는 1이라는 숫자의 입력이 필요하다
q1 -> 0 -> q3 q1에서 q3로 이동하기 위해서는 0이라는 숫자의 입력이 필요하다

위처럼 각 입력에 따라 다른 상태를 넣어주면 된다.

```cpp
#include <bits/stdc++.h>

using namespace std;
int D[10][2], ck[10];
int N;

void dfa(){
    int cur = 1;
    string s; cin >> s;
    for(auto ch : s){
        cur = D[cur][ch-'0'];
    }
    if(ck[cur]) cout <<"YES\n";
    else cout <<"NO\n";
}

int main(void){
    cin.tie(0)->sync_with_stdio(0);
    D[1][0] = 2; D[1][1] = 3;
    D[2][1] = 1;
    D[3][0] = 4;
    D[4][0] = 5;
    D[5][0] = 5; D[5][1] = 6;
    D[6][0] = 2; D[6][1] = 7;
    D[7][0] = 8; D[7][1] = 7;
    D[8][0] = 5; D[8][1] = 1;
    ck[1] = ck[6] = ck[7] = 1;
    cin >> N;
    while(N--){
        dfa();
    }
    
}
```

DFA에 대해 공부하기 좋은 문제였던것 같다.

### BOJ 2761 

위 문제와 동일하다

#### BOJ 2240

- 매 초마다 두개의 나무중 한군데에서 사과가떨어짐
- 이동횟수가 정해져있을때, 최대로 사과를 얻는 개수를 구해야함

이번 구현에서 익명함수를 써보았고, 해당처럼 구현이 가능하다.

```cpp
#include <bits/stdc++.h>

using namespace std;
using pii = pair<int,int>;

int main(void){
    cin.tie(0)->sync_with_stdio(0);
    int N, M ,K;
    cin >> N>> M >>K;
    vector<int> cnt(N+1);
    vector<pii> top(M+1);
    map<pii,int> mp;
    
    int ans = 0;
    
    auto u = [&](int i,int j, int p){
        int &k = mp[{i,j}];
        k += p;
        
        if(top[j].second < k){
            if(cnt[top[j].first] == K) ans--;
            cnt[top[j].first]--;
            cnt[i]++;
            if(cnt[i]==K) ans++;
            top[j] = {i,k};
        }
    };
    
    
    for(int i = 1; i<=N;i++){
        for(int j = 0;j<K;j++){
            int a,b;
            cin >> a >> b;
            u(i,a,b);
        }
    }
    
    int Q; cin >> Q;
    while(Q--){
        int i,j,k;
        
        cin >> i>> j >> k;
        u(i,j,k);
        cout << ans <<"\n";
    }
    
}
```

map 의 key 값은 꼭 int가 아니어도 다양한 자료형이 들어갈수 있다. 이를 참고하면 더 많은 문제를 빠르게 풀수 있을것이다.


#### BOJ 31264

이분탐색을 어떻게 써야하는가에 대해 정리할수 있는 문제

브루트포스로 해결이 안됨은 이분탐색을 이용하자

```cpp
#include <bits/stdc++.h>

using namespace std;
int N, M;
long long A;
vector<int> s;

long long f(int k){
    int m = M; long long ans = 0;
    while(m--){
        int p = *(upper_bound(s.begin(), s.end(), k)-1);
        ans += p;
        k += p;
    }
    return ans;
}

void binary_search(){
    int l = 0, r = 100001;
    while(l <= r){
        int mid = (l+r)/2;
        if(f(mid) < A) l = mid +1;
        else r = mid -1;
    }
    cout << l;
}

int main(void){
    
    cin >> N >> M >>A;
    s.resize(N);
    for(auto &i : s) cin >> i;
    sort(s.begin(), s.end());
    binary_search();
    
    
}
```


#### BOJ 14567

위상정렬 기본문제

```cpp
#include <bits/stdc++.h>

using namespace std;

vector<int> g[1001];
int indegree[1001],ans[1001];
int main(void){
    int N, M;
    cin >> N >> M;
    

    for(int i = 0;i<M;i++){
        int A, B; cin >> A >>B;
        g[A].push_back(B);
        indegree[B]++;
        
    }
    queue<int> q;
    
    for(int i = 1; i<=N;i++){
        if(indegree[i] == 0) q.push(i);
        ans[i] = 1;
    }
    while(!q.empty()){
        int cur = q.front(); q.pop();
        for(auto nxt : g[cur]){
            if(--indegree[nxt] == 0){
                q.push(nxt);
                ans[nxt] = max(ans[nxt], ans[cur]+1);
            }
        }
    }
    for(int i = 1; i<=N;i++) cout << ans[i] <<" ";
}
```

