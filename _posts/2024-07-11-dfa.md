---
layout: post
title:  "결정적 유한 오토마타(DFA)"
categories: ps
use_math: true
---

### Deterministic Finite Automata (결정적 유한 오토마타)

이전에 알고리즘을 공부하다가 우연히 오토마타를 알게 되었다. 문자열에서 특정한 문자가 들어가있는지 알아보는것이 정규표현식이랑 비슷하여 공부를 해보았다.

생각해보면 정규표현식과 동일하므로, 정규표현식 문제들은 모두 DFA로 치환하여 구할 수 있다.


#### 오토마타

다음은 오토마타의 성질이다.
- 유한개의 내부상태
- 유한 / 무한개의 크기를 담는 저장공간
- 입력이 주어지면 정해진 방식에 따라 상태 전이

자세한 오토마타의 내용은 justice hui 님의 강의 자료와 알고리즘 트레이닝 을 참고하면 될것같다.

해당 DFA를 사용하기 위해 DP를 사용할 수 있으며
DP(x,y) : 상태 번호가 x일때, y가 주어질때 이동하는 상태번호 라고 정할수 있다.

이를 이용하여 BOJ 1013을 풀수 있었다.

### BOJ 1013

- 주어진 식 (100+1+|01)+ 을 이용하여 주어진 문자열이 해당 식을 만족하는지 여부 판단
- 1과 0이 주어지고, 해당 숫자에 따라 상태가 바뀐다

q0은 종료 상태이다. 어떤 상태든 q0으로 가는 상태 즉 0으로 가는 상태는 모두 out 조건이다.

모든 문자열은 q1에서 시작한다.
q1 -> 1 -> q2 q1에서 q2로 이동하기 위해서는 1이라는 숫자의 입력이 필요하다
q1 -> 0 -> q3 q1에서 q3로 이동하기 위해서는 0이라는 숫자의 입력이 필요하다

위처럼 각 입력에 따라 다른 상태를 넣어주면 된다.

```c++
#include <bits/stdc++.h>

using namespace std;
int D[10][2], ck[10];
int N;

void dfa(){
    int cur = 1;
    string s; cin >> s;
    for(auto ch : s){
        cur = D[cur][ch-'0'];
    }
    if(ck[cur]) cout <<"YES\n";
    else cout <<"NO\n";
}

int main(void){
    cin.tie(0)->sync_with_stdio(0);
    D[1][0] = 2; D[1][1] = 3;
    D[2][1] = 1;
    D[3][0] = 4;
    D[4][0] = 5;
    D[5][0] = 5; D[5][1] = 6;
    D[6][0] = 2; D[6][1] = 7;
    D[7][0] = 8; D[7][1] = 7;
    D[8][0] = 5; D[8][1] = 1;
    ck[1] = ck[6] = ck[7] = 1;
    cin >> N;
    while(N--){
        dfa();
    }
    
}
```

DFA에 대해 공부하기 좋은 문제였던것 같다.

### BOJ 2761 

위 문제와 동일하다

