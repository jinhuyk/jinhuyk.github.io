---
layout: post
title:  "240705-240810 set"
categories: ps
use_math: true
---
240705 - 240810 problem set


#### BOJ 2240

- 매 초마다 두개의 나무중 한군데에서 사과가떨어짐
- 이동횟수가 정해져있을때, 최대로 사과를 얻는 개수를 구해야함

```cpp
#include <bits/stdc++.h>

using namespace std;

int d[1001][31][2], a[1001];
int T,W;

int dp(int t, int w, int cur){
    if(t > T) return 0;
    int &ret = d[t][w][cur];
    if(ret != -1) return ret;
    ret = (cur == a[t]) + dp(t+1,w,cur);
    if(w < W) ret = max(ret, (cur != a[t]) + dp(t+1, w+1, !cur));
    return ret;
}


int main(void){
    cin >> T >> W;
    for(int i = 1;i<=T;i++) {cin >> a[i]; a[i]--;}
    memset(d,-1,sizeof(d));
    cout << dp(1,0,0);
}
```

#### BOJ 30049

- 구현은 단순하지만, 시간복잡도를 어떻게 줄일수 있을지 생각해야함

$O(QMN\log N)$ 풀이 - 시간초과

```cpp
#include <bits/stdc++.h>

using namespace std;


int Ma[100000][101];
int N,M,K;
int main(void){
    cin.tie(0)->sync_with_stdio(0);
    
    cin >> N>> M >>K;
    
    for(int i = 1;i <=N;i++){
        for(int j = 0;j<K;j++){
            int jj, tt; cin >> jj >> tt;
            Ma[jj][i] = tt;
        }
    }
    
    int Q; cin >> Q;
    
    while(Q--){
        
        int i,j,p; cin >> i>>j>>p;
        
        Ma[j][i] += p;
        
        priority_queue<pair<int,int>> pq[M+1];
        int cnt[N+1];
        for(int i = 1; i<=M;i++){
            for(int j = 1; j<=N;j++){
                cnt[j] = 0;
                if(Ma[i][j] == 0) continue;
                pq[i].push({Ma[i][j],j});
            }
        }
        for(int i = 1; i<=M;i++){
            if(pq[i].empty()) continue;
            cnt[pq[i].top().second]++;
        }
        int ret = 0;
        for(int i = 1;i<=N;i++){
            if(cnt[i] == K) ret++; 
        }
        cout << ret <<"\n";
        
    }
}
```

위의 문제를 충분히 구현할 수 있지만, 시간 초과가 난다.

즉 저기에서 시간을 단축해야한다.

이번 구현에서 익명함수를 써보았고, 해당처럼 구현이 가능하다.

```cpp
#include <bits/stdc++.h>

using namespace std;
using pii = pair<int,int>;

int main(void){
    cin.tie(0)->sync_with_stdio(0);
    int N, M ,K;
    cin >> N>> M >>K;
    vector<int> cnt(N+1);
    vector<pii> top(M+1);
    map<pii,int> mp;
    
    int ans = 0;
    
    auto u = [&](int i,int j, int p){
        int &k = mp[{i,j}];
        k += p;
        
        if(top[j].second < k){
            if(cnt[top[j].first] == K) ans--;
            cnt[top[j].first]--;
            cnt[i]++;
            if(cnt[i]==K) ans++;
            top[j] = {i,k};
        }
    };
    
    
    for(int i = 1; i<=N;i++){
        for(int j = 0;j<K;j++){
            int a,b;
            cin >> a >> b;
            u(i,a,b);
        }
    }
    
    int Q; cin >> Q;
    while(Q--){
        int i,j,k;
        
        cin >> i>> j >> k;
        u(i,j,k);
        cout << ans <<"\n";
    }
    
}
```

map 의 key 값은 꼭 int가 아니어도 다양한 자료형이 들어갈수 있다. 이를 참고하면 더 많은 문제를 빠르게 풀수 있을것이다.


