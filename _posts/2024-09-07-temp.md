---
layout: post
title:  "Templete - 알고리즘 템플릿 정리"
categories: ps templete
use_math: true
---

앞으로의 포스트 진행 방향 및 목표

1. 알고리즘 정리

기본적인 알고리즘은 링크 등으로 대체 하며, 알고리즘 공부하면서 중요하거나 필요한 부분들만 중점으로 (중요점, 구현 방향 등) 포스팅
- math algorithm
- search algorithm
- dynamic programming
- data structures
- graph algorithm
- geometric algorithm

정도로 정리 후 세부적으로 진행할 예정

2. 알고리즘 문제풀이 정리

기본적으로 문제풀이는 알고리즘 정리에서 부록으로 넣어놀 예정이나, USACO 등 경진대회에서 중요한 문제라고 생각되는 것들은 따로 올릴 예정
BOJ 내부 contest 등도 정리하거나 올려볼 예정(추후 조정)

3. CS 지식 정리

2025년 이후, 복학 하면 다시 정리해볼 예정
주요 과목에서 진행하며, 알고리즘 정리와 마찬가지로 비슷하게 진행할예정

### 유용한 사이트

### COCI
[COCI solution site](https://hsin.hr/coci/)

[COCI problem site](https://www.acmicpc.net/category/17)

Bronze 이상 문제푸터 풀고, solution 과 비교 및 최적화 연습

#### USACO
[USACO problem site](https://www.acmicpc.net/category/106)

usaco bronze 부터 문제풀이 , 포스팅 부탁

#### Project Euler

수학 연습용 사이트

[https://www.onlinegdb.com/online_c++_compiler   ](https://www.onlinegdb.com/online_c++_compiler)




#### 자주사용하는 Templete
기본적으로 많이 사용하는 PS 템플릿 

~~~cpp
#include <algorithm>
#include <iostream>
#include <vector>
#include <cmath>
#include <queue>
#include <stack>
#include <deque>

using namespace std;

typedef long long ll;
typedef pair<int,int> ii;
typedef vector<ii> vii;
typedef vector<int> vi;
typedef tuple<int,int,int> iii;
~~~

#### 기하 Templete
~~~cpp
#include <algorithm>
#include <iostream>
#include <vector>
#include <cmath>
#include <queue>
#include <stack>
#include <deque>

using namespace std;

typedef long long ll;
typedef pair<int,int> ii;
typedef vector<ii> vii;
typedef vector<int> vi;
typedef tuple<int,int,int> iii;

using Point = pair<int64_t, int64_t>;
#define X first
#define Y second

Point operator - (const Point &p, const Point &q){
    return {p.X-q.X, p.Y-q.Y};
}
Point operator + (const Point &p, const Point &q){
    return {p.X+q.X, p.Y+q.Y};
}
bool cmp(const Point&p, const Point &q){
    if(p.Y != q.Y) return p.Y > q.Y;
    return p.X < q.X;
}
int64_t cross(const Point &p, const Point &q){
    return p.X*q.Y - q.X*p.Y;
}

int64_t ccw(Point p, Point q, Point r){
    int64_t c = cross(q-p, r-q);
    if(c > 0) return 1;
    else if(c == 0) return c;
    else return -1;
}
~~~

#### FASTIO
cin, cout 는 속도가 느리기 때문에 다음을 main 안에 넣어놓고 사용한다.

```cpp
cin.tie(0)->sync_with_stdio(0);
```


#### 자주 사용되는 입출력 루틴

~~~cpp
// 테스트케이스가 있는 경우
int TC; cin >> TC;
while(TC--){
    //program
}

// 입력의 끝부분에 특정 값이 주어지는 경우

int a,b;
//만약 a == b == 0 인경우 프로그램 종료
while(scanf("%d %d",&a,&b), (a || b)){
    //program
}
~~~


#### 비트 연산
정수인 수들을 다루다보면 비트로 연산하는게 코드가 훨씬 간결하다.

```cpp
// 짝 홀수 판별
N&1 --> even : 0 , odd : 1

// K+1 번째 자리수 (2진법)
n >> k&1

// n은 2의 거듭제곱수
!(n&(n-1)) 

// 나누기 2
n >> 1
```

#### 비트를 사용하여 집합으로 나타내기
bit를 이용하여 집합을 표현한다면 다음처럼 사용할 수 있음

집합의 j 번째의 원소를 켜기 - Or 연산 사용

```cpp
S |= (1 << j) 
```

집합의 j 원소가 켜져 있는지 확인하려면 And 연산을 사용한다.

```cpp
T = S & (1 << j)
if( T == 0) j 번쨰 원소는 꺼져있음
```

집합의 j 번쨰 원소 끄기 - And 사용

```cpp
S &= ~(1 << j)
```

집합의 j 번쨰 원소 반전 - XOR 사용

```cpp
S &= ~(1 << j)
```

켜져 있는 최하위 비트를 구하기(오른쪽)

```cpp
T = (S & (-S) )

```

크기가 n 인 집합의 모든 비트 켜기

```cpp
S = (1 << n) -1
```

---

어떤 수가 0부터 9까지 모두 사용되었는지 확인

```cpp
while(tmp) { T |= 1 >> (tmp % 10); tmp /= 10;}
if(T == (1 << 10) -1) return true;
```